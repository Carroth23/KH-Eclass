<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <!-- REPL -->
    <!-- Read Eval Print Loop -->
    <script>
        console.log('Hello World!');
        console.log('줄바꿈\n기릿');
        console.log(typeof function(){}); // 타입 확인
        console.log(typeof""); // 얘도 문자열
        console.log("'");
        console.log('"정말"그랬니?');
        console.log('how\'re you?');
        // 코드 중간 줄바꿈은 쉬프트+엔터

        // NaN = Not a Number

        parseInt('123'); // 문자열을 숫자로 변환
        Number('123'); // 문자열을 숫자로 변환
        parseInt('3.14'); // 3
        parseFloat('3.14'); // 3.14
        Number('3.14'); // 3.14
        // parseInt(111, 2); // 111을 2진법으로 해석
        // parseInt(prompt()); prompt()로 값을 입력 후 parseInt함
        // 2**3 // 2의 3거듭제곱
        // '1' + 0 = '10'
        // '123' - 23 = 100
        // 2 / 0 // Infinity

        // 0.1 + 0.2 = 0.30000000000000004 // 부동소수점 문제
        // (0.3 *10 - 0.1 *10) / 10 // 0.2 // 부동소수점 문제 극복

        // NaN == NaN // false 얘는 왜 false 일까
        // true > false // true // 결국 true가 1과 비슷 false가 0


        // '&'.charCodeAt() // 65286
        // 'a'.charCodeAt() // 98

        // '3' < 5; // true // <은 '3'을 숫자로 만들어버림
        // 0 < true = true


        // 1 == '1' = true // 값만 비교
        // 1 == true = true
        // 1 === '1' = false // 자료형까지 비교
        // 1 === true = false

        // 1 != '1' = false // 값만 비교
        // 1 !== '1' = true // 자료형까지 비교

        // !!'a'; // 문자가 true인지 false 인지. !!로 두번 뒤집어 현재의 값을 알아냄.
        // 근데 대부분 true다.

        // typeof null == object // 얘는 유명한 버그 원래 null이 나와야 정상
    </script>
</body>
</html>